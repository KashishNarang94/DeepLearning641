# -*- coding: utf-8 -*-
"""Q2b.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10GtYqGnq4U3QInsnq2Lztr7FQfyk8Qaq
"""

import pandas as pd
data = pd.read_csv("/content/drive/MyDrive/Shared DL Assignment Folder/A1/q2b_dataset.csv")
data

label = list(data["Label"])
data = data.drop(["Label"], axis = 1)
data

w = []
w.append([[0.5]*2]*8)
w.append([[1]*4]*2)
w.append([[-1.4425, 1.23], [0.40249999999999997, -0.44999999999999996]])
w.append([0.5, 0.5])
b = []
b.append([0.5]*8)
b.append([-3]*2)
b.append([-0.22999999999999998, -0.20125000000000004])
b.append(0.5)

print("weight",w[2])
print("bias",b[2])

from random import uniform
for i in range(0, len(w[0])):
    for j in range(0,2):
        num = uniform(-1,1)
        num = round(num,2)
        w[0][i][j] = num

for i in range(0, len(b[0])):
    num = uniform(-1,1)
    num = round(num,2)
    b[0][i] = num

print("weight",w[0])
print("bias",b[0])

import numpy as np
def compute_hidden_layer1(w, b, index):
    z = [0]*8
    o = [-1]*8
    for i in range(0, 8):
        we = np.array(w[0][i])
        x = np.array(list(data.iloc[index]))
        t = np.dot(we.T, x)
        t = t + b[0][i]
        z[i] = t
        if(t>=0):
            o[i] = 1
        else:
            o[i] = -1
    return z, o

def compute_hidden_layer2(w, b, o1):
    z = [0]*2
    o = [-1]*2
    for i in range(0, 2):
        we = np.array(w[1][i])
        x = np.array(o1[(i*4):(i*4+4)])
        t = np.dot(we.T, x)
        t = t + b[1][i]
        z[i] = t
        if(t>=0):
            o[i] = 1
        else:
            o[i] = -1
    return z, o

def compute_hidden_layer3(w, b, o2):
    z = [0]*2
    o = [-1]*2
    for i in range(0, 2):
        we = np.array(w[2][i])
        x = np.array(o2)
        t = np.dot(we.T, x)
        t = t + b[2][i]
        z[i] = t
        if(t>=0):
            o[i] = 1
        else:
            o[i] = -1
    return z, o

def compute_output(w, b, o):
    we = np.array(w[3])
    x = np.array(o)
    t = np.dot(we.T, x)
    t = t + b[3]
    if(t>=0):
        return [t,1]
    else:
        return [t,-1]

for i in range(0, 1):
    z1, o1 = compute_hidden_layer1(w,b,i)
    print(o1)
    z2, o2 = compute_hidden_layer2(w,b,o1)
    print(o2)
    z3, o3 = compute_hidden_layer3(w,b,o2)
    print(o3)    
    z4, o4 = compute_output(w,b,o3)
    print(o4)

# from sklearn.metrics import accuracy_score
# from tqdm import tqdm
# parameter = 0.01
# for epoch in tqdm(range(10)):
#     for i in range(0,len(data)):
# #         print("=============", i, "================")
#         z1, o1 = compute_hidden_layer1(w,b,i)
#         z2, o2 = compute_hidden_layer2(w,b,o1)
#         z3, o3 = compute_hidden_layer3(w,b,o2)
#         z4, o4 = compute_output(w,b,o3)
#         temp = [0]*len(z1)
#         for j in range(len(z1)):
#             temp[j] = z1[j]
#         for k in range(0, 8): # 8 is number of neurns to be updated
#             if(o4 != label[i]):
#                 minimum = min(temp)
#                 index = -1
#                 for j in range(len(temp)):
#                     if(temp[j] == minimum):
#                         index = j
#                         temp[index] = 1000
#                         break
#                 t_o1 = [0]*len(o1)
#                 for j in range(len(o1)):
#                     if(j!=index):
#                         t_o1[j] = o1[j]
#                     else:
#                         if(o1[j]==1):
#                             t_o1[j] = -1
#                         else:
#                             t_o1[j] = 1

#                 _, t_o2 = compute_hidden_layer2(w,b,t_o1)
#                 _, t_o3 = compute_hidden_layer3(w,b,t_o2)
#                 _, t_o4 = compute_output(w,b,t_o3)
#                 if(t_o4 == label[i]):
#                     # Perform Adaline on INDEXth neuron
#                     #print("Adaline")
#                     w[0][index] = list(np.add(w[0][index], (((parameter) * (t_o1[index]-z1[index])) * np.array(list(data.iloc[i])))))
#                     b[0][index] = b[0][index] + (parameter) * (t_o1[index]-z1[index])
#                     break
#             else:
#                 break
#     y_pred = []
#     for i in range(0, len(data)):
#         _, t = compute_hidden_layer1(w,b,i)
#         _, t1 = compute_hidden_layer2(w,b,t)
#         _, t2 = compute_hidden_layer3(w,b,t1)
#         _, out = compute_output(w,b,t2)
#         y_pred.append(out)
#     print(epoch, accuracy_score(y_pred, label))

from sklearn.metrics import accuracy_score
from tqdm import tqdm
parameter = 0.01
for epoch in (range(10)):
    for i in range(0,len(data)):
#         print("=============", i, "================")
        z1, o1 = compute_hidden_layer1(w,b,i)
        z2, o2 = compute_hidden_layer2(w,b,o1)
        z3, o3 = compute_hidden_layer3(w,b,o2)
        z4, o4 = compute_output(w,b,o3)
        temp = [0]*len(z1)
        for j in range(len(z1)):
            temp[j] = z1[j]
        for k in range(0, 8): # 8 is number of neurns to be updated
            if(o4 != label[i]):
                minimum = min(temp)
                index = -1
                for j in range(len(temp)):
                    if(temp[j] == minimum):
                        index = j
                        temp[index] = 1000
                        break
                t_o1 = [0]*len(o1)
                for j in range(len(o1)):
                    if(j!=index):
                        t_o1[j] = o1[j]
                    else:
                        if(o1[j]==1):
                            t_o1[j] = -1
                        else:
                            t_o1[j] = 1

                _, t_o2 = compute_hidden_layer2(w,b,t_o1)
                _, t_o3 = compute_hidden_layer3(w,b,t_o2)
                _, t_o4 = compute_output(w,b,t_o3)
                if(t_o4 == label[i]):
                    # Perform Adaline on INDEXth neuron
                    #print("Adaline")
                    w[0][index] = list(np.add(w[0][index], (((parameter) * (t_o1[index]-z1[index])) * np.array(list(data.iloc[i])))))
                    b[0][index] = b[0][index] + (parameter) * (t_o1[index]-z1[index])
                    break
            else:
                break
    y_pred = []
    for i in range(0, len(data)):
        _, t = compute_hidden_layer1(w,b,i)
        _, t1 = compute_hidden_layer2(w,b,t)
        _, t2 = compute_hidden_layer3(w,b,t1)
        _, out = compute_output(w,b,t2)
        y_pred.append(out)
    print("############# Epoch",epoch, "accuracy score",accuracy_score(y_pred, label),"#############")